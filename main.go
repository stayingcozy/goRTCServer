package main

import (
	"context"
	"fmt"
	"log"
	"math/rand"
	"os"
	"strconv"
	"strings"
	"time"

	"bytes"
	"image/jpeg"

	"github.com/pion/rtp"
	"github.com/pion/rtp/codecs"
	"github.com/pion/webrtc/v4/pkg/media/samplebuilder"
	"golang.org/x/image/vp8"

	"github.com/pion/interceptor"
	"github.com/pion/interceptor/pkg/intervalpli"
	"github.com/pion/webrtc/v4"
	"github.com/pion/webrtc/v4/pkg/media"
	"github.com/pion/webrtc/v4/pkg/media/ivfwriter"
	"github.com/pion/webrtc/v4/pkg/media/oggwriter"

	"cloud.google.com/go/firestore"
	firebase "firebase.google.com/go"
	"google.golang.org/api/option"
)

var rtpChan chan *rtp.Packet

const MAX_JPG_FILES int = 50

func remove(s []int, i int) []int {
	s[i] = s[len(s)-1]
	return s[:len(s)-1]
}

func jpgFileWrangler() int {
	files, err := os.ReadDir("./")
	if err != nil {
		fmt.Println("Error reading the directory:", err)
		return 0
	}

	jpgCount := 0

	for _, file := range files {
		if !file.IsDir() && strings.HasSuffix(file.Name(), ".jpg") {
			jpgCount++
		}
	}

	for jpgCount > MAX_JPG_FILES {
		indexDel := rand.Intn((jpgCount - 2)) + 2 // shift by two to avoid deleting an image ML algo is reading
		fileDel := files[indexDel]
		if !fileDel.IsDir() && strings.HasSuffix(fileDel.Name(), ".jpg") {
			e := os.Remove(fileDel.Name())
			if e != nil {
				log.Fatal(e)
			}
			jpgCount--
		}
	}

	fmt.Printf("Number of .jpg files in the current folder: %d\n", jpgCount)

	return jpgCount
}

func saveToDisk(i media.Writer, track *webrtc.TrackRemote) {
	defer func() {
		if err := i.Close(); err != nil {
			panic(err)
		}
	}()

	go snapshot()

	for {
		rtpPacket, _, err := track.ReadRTP()
		if err != nil {
			fmt.Println(err)
			return
		}
		if err := i.WriteRTP(rtpPacket); err != nil {
			fmt.Println(err)
			return
		}
		// Use a lossy channel to send packets to snapshot handler
		// We don't want to block and queue up old data
		select {
		case rtpChan <- rtpPacket:
		default:
		}
	}
}

func snapshot() {
	// Initialized with 20 maxLate, my samples sometimes 10-15 packets
	sampleBuilder := samplebuilder.New(20, &codecs.VP8Packet{}, 90000)
	decoder := vp8.NewDecoder()

	for {
		// Pull RTP Packet from rtpChan
		sampleBuilder.Push(<-rtpChan)

		// Use SampleBuilder to generate full picture from many RTP Packets
		sample := sampleBuilder.Pop()
		if sample == nil {
			continue
		}

		// Read VP8 header.
		videoKeyframe := (sample.Data[0]&0x1 == 0)
		if !videoKeyframe {
			continue
		}

		// Begin VP8-to-image decode: Init->DecodeFrameHeader->DecodeFrame
		decoder.Init(bytes.NewReader(sample.Data), len(sample.Data))

		// Decode header
		if _, err := decoder.DecodeFrameHeader(); err != nil {
			panic(err)
		}

		// Decode Frame
		img, err := decoder.DecodeFrame()
		if err != nil {
			panic(err)
		}

		// Create image
		t := time.Now()
		f, err := os.Create(fmt.Sprintf("img_%s.jpg", t.Format("2000_01_01_15_04_05")))
		if err != nil {
			panic(err)
		}
		if err = jpeg.Encode(f, img, nil); err != nil {
			panic(err)
		}

	}
}

func main() {

	rtpChan = make(chan *rtp.Packet)

	//// Firebase init /////

	const uid = os.Getenv("UID") // hardcode my uid
	const serviceAccountKey = os.Getenv("SERVICE_ACCOUNT_KEY")
	const projectID = os.Getenv("PROJECT_ID")

	// Initialize Cloud Firestore
	opt := option.WithCredentialsFile(path_to_serviceAccountKey)
	app, err := firebase.NewApp(context.Background(), nil, opt)
	if err != nil {
		fmt.Println("error initializing app: %w", err)
	}

	// Initialize the Firebase Admin SDK
	ctx := context.Background()

	///////////////////////

	// go jpgFileWrangler() // Keep jpg file count in check to prevent overload

	//////////////////////

	// Create a MediaEngine object to configure the supported codec
	m := &webrtc.MediaEngine{}

	// Setup the codecs you want to use.
	// We'll use a VP8 and Opus but you can also define your own
	if err := m.RegisterCodec(webrtc.RTPCodecParameters{
		RTPCodecCapability: webrtc.RTPCodecCapability{MimeType: webrtc.MimeTypeVP8, ClockRate: 90000, Channels: 0, SDPFmtpLine: "", RTCPFeedback: nil},
		PayloadType:        96,
	}, webrtc.RTPCodecTypeVideo); err != nil {
		panic(err)
	}
	if err := m.RegisterCodec(webrtc.RTPCodecParameters{
		RTPCodecCapability: webrtc.RTPCodecCapability{MimeType: webrtc.MimeTypeOpus, ClockRate: 48000, Channels: 0, SDPFmtpLine: "", RTCPFeedback: nil},
		PayloadType:        111,
	}, webrtc.RTPCodecTypeAudio); err != nil {
		panic(err)
	}

	//// Possibly remove this chunk ////

	// Create a InterceptorRegistry. This is the user configurable RTP/RTCP Pipeline.
	// This provides NACKs, RTCP Reports and other features. If you use `webrtc.NewPeerConnection`
	// this is enabled by default. If you are manually managing You MUST create a InterceptorRegistry
	// for each PeerConnection.
	i := &interceptor.Registry{}

	// Register a intervalpli factory
	// This interceptor sends a PLI every 3 seconds. A PLI causes a video keyframe to be generated by the sender.
	// This makes our video seekable and more error resilent, but at a cost of lower picture quality and higher bitrates
	// A real world application should process incoming RTCP packets from viewers and forward them to senders
	intervalPliFactory, err := intervalpli.NewReceiverInterceptor()
	if err != nil {
		panic(err)
	}
	i.Add(intervalPliFactory)

	// Use the default set of Interceptors
	if err = webrtc.RegisterDefaultInterceptors(m, i); err != nil {
		panic(err)
	}

	/////////////////////////////

	// Create the API object with the MediaEngine
	api := webrtc.NewAPI(webrtc.WithMediaEngine(m), webrtc.WithInterceptorRegistry(i))

	// Prepare the configuration
	config := webrtc.Configuration{
		ICEServers: []webrtc.ICEServer{
			{
				URLs: []string{"stun:stun.l.google.com:19302"},
			},
		},
	}

	// Create a new RTCPeerConnection
	peerConnection, err := api.NewPeerConnection(config)
	if err != nil {
		panic(err)
	}

	// Allow us to receive 1 audio track, and 1 video track
	if _, err = peerConnection.AddTransceiverFromKind(webrtc.RTPCodecTypeAudio); err != nil {
		panic(err)
	} else if _, err = peerConnection.AddTransceiverFromKind(webrtc.RTPCodecTypeVideo); err != nil {
		panic(err)
	}

	oggFile, err := oggwriter.New("output.ogg", 48000, 2)
	if err != nil {
		panic(err)
	}
	ivfFile, err := ivfwriter.New("output.ivf")
	if err != nil {
		panic(err)
	}

	// Set a handler for when a new remote track starts, this handler saves buffers to disk as
	// an ivf file, since we could have multiple video tracks we provide a counter.
	// In your application this is where you would handle/process video
	peerConnection.OnTrack(func(track *webrtc.TrackRemote, receiver *webrtc.RTPReceiver) {
		codec := track.Codec()
		if strings.EqualFold(codec.MimeType, webrtc.MimeTypeOpus) {
			fmt.Println("Got Opus track, saving to disk as output.opus (48 kHz, 2 channels)")
			saveToDisk(oggFile, track)
		} else if strings.EqualFold(codec.MimeType, webrtc.MimeTypeVP8) {
			fmt.Println("Got VP8 track, saving to disk as output.ivf")
			saveToDisk(ivfFile, track)
		}
	})

	// Set the handler for ICE connection state
	// This will notify you when the peer has connected/disconnected
	peerConnection.OnICEConnectionStateChange(func(connectionState webrtc.ICEConnectionState) {
		fmt.Printf("Connection State has changed %s \n", connectionState.String())

		if connectionState == webrtc.ICEConnectionStateConnected {
			fmt.Println("Ctrl+C the remote client to stop the demo")
		} else if connectionState == webrtc.ICEConnectionStateFailed || connectionState == webrtc.ICEConnectionStateClosed {
			if closeErr := oggFile.Close(); closeErr != nil {
				panic(closeErr)
			}

			if closeErr := ivfFile.Close(); closeErr != nil {
				panic(closeErr)
			}

			fmt.Println("Done writing media files")

			// Gracefully shutdown the peer connection
			if closeErr := peerConnection.Close(); closeErr != nil {
				panic(closeErr)
			}

			os.Exit(0)
		}
	})

	///////////////////

	// Setup Context
	ctx, cancel := context.WithCancel(ctx)
	defer cancel()

	client, err := app.Firestore(ctx)
	if err != nil {
		log.Fatalln(err)
	}

	if err != nil {
		fmt.Println("firestore.NewClient: %w", err)
	}
	defer client.Close()

	// firebase ref's
	var callRef = client.Collection("users").Doc(uid).Collection("calls").NewDoc()
	offerCandidates := callRef.Collection("offerCandidates").NewDoc()
	uidDoc := client.Collection("users").Doc(uid)

	// // set latest caller + upload to firebase
	// _, Uerr := uidDoc.Update(ctx, []firestore.Update{
	// 	{
	// 		Path:  "latestCall",
	// 		Value: callRef.ID,
	// 	},
	// })
	// if Uerr != nil {
	// 	// Handle any errors in an appropriate way, such as returning them.
	// 	log.Printf("An error has occurred when updating latest call: %s", Uerr)
	// }

	// Register the onICECandidate event handler (offer candidate + upload to fb)
	peerConnection.OnICECandidate(func(event *webrtc.ICECandidate) {
		// onICECandidateJS(peerConnection, event, ctx)
		if event != nil {
			candidateJSON := event.ToJSON()

			// Convert to readable format on Firebase for User on WebRTC js side to process
			offercandidateFB := OfferCandidateFB{
				Candidate:     candidateJSON.Candidate,
				SDPMLineIndex: int64(*candidateJSON.SDPMLineIndex),
				SDPMid:        strconv.Itoa(int(*candidateJSON.SDPMLineIndex)), // value is blank, so use SDPMLineIndex for now
			}

			_, err := offerCandidates.Set(ctx, offercandidateFB)
			if err != nil {
				// Handle any errors in an appropriate way, such as returning them.
				log.Printf("An error has occurred on setting offerCandidates: %s", err)
			}

		}
	})

	// Create offer
	offerDescription, err := peerConnection.CreateOffer(nil)
	if err != nil {
		panic(err)
	}

	// set local desc
	peerConnection.SetLocalDescription(offerDescription)

	// upload to firebase
	soff := StartOffer{
		example: "placeholder",
	}
	SecOffer := Offer{
		Type: "offer",
		SDP:  offerDescription.SDP,
	}
	// Offer := OuterOffer{
	// 	Offer: Offer{
	// 		Type: "offer",
	// 		SDP:  offerDescription.SDP,
	// 	},
	// }
	// fmt.Println(Offer)
	// _, UOerr := callRef.Update(ctx, []firestore.Update{
	// 	{
	// 		Path:  "offer",
	// 		Value: offer,
	// 	},
	// })
	_, UOerr := callRef.Set(ctx, soff) // then updat ?
	if UOerr != nil {
		// Handle any errors in an appropriate way, such as returning them.
		log.Printf("An error has occurred on offer upload update: %s", UOerr)
	}
	_, UOerr2 := callRef.Update(ctx, []firestore.Update{
		{
			Path:  "offer",
			Value: SecOffer,
		},
	})
	if UOerr2 != nil {
		// Handle any errors in an appropriate way, such as returning them.
		log.Printf("An error has occurred on offer upload update: %s", UOerr2)
	}

	// set latest caller + upload to firebase
	_, Uerr := uidDoc.Update(ctx, []firestore.Update{
		{
			Path:  "latestCall",
			Value: callRef.ID,
		},
	})
	if Uerr != nil {
		// Handle any errors in an appropriate way, such as returning them.
		log.Printf("An error has occurred when updating latest call: %s", Uerr)
	}

	// onSnapshot - listen for remote answer
	// set remote desc
	dit := callRef.Snapshots(ctx)
	for {
		snap, err := dit.Next()
		// DeadlineExceeded will be returned when ctx is cancelled.
		// if status.Code(err) == codes.DeadlineExceeded {
		// 	return
		// }
		if err != nil {
			return
		}
		// if !snap.Exists() {
		// 	fmt.Println("Document no longer exists")
		// 	return
		// }
		if snap != nil {
			data := snap.Data()

			// check if data map has key answer
			_, hasAnswer := data["answer"]
			CurrRemoteDesc := peerConnection.CurrentRemoteDescription()
			fmt.Println("Current Remote Desc")
			fmt.Println(CurrRemoteDesc)

			if hasAnswer && CurrRemoteDesc == nil {
				answerDescription := data["answer"]
				// Break down interface into sdp
				if value, ok := answerDescription.(map[string]interface{}); ok {
					fieldValue := value["sdp"]
					if sdpStrValue, ok := fieldValue.(string); ok {

						// Set the remote SessionDescription
						answer := webrtc.SessionDescription{
							Type: webrtc.SDPTypeAnswer,
							SDP:  sdpStrValue,
						}

						// Create channel that is blocked until ICE Gathering is complete
						fmt.Println("Starting setRemoteDescription")
						fmt.Println(answer)
						fmt.Println("Ended Answer")
						// gatherCompleteRem := webrtc.GatheringCompletePromise(peerConnection)
						var err error
						if err = peerConnection.SetRemoteDescription(answer); err != nil {
							panic(err)
						}

						///////////

						// onSnapshot - get answer candidates
						// Add answerCandidates to RTCIceCandidate
						fmt.Println("\nChecking docs in answerCandidates....")
						oCit := callRef.Collection("answerCandidates").Snapshots(ctx)
						for {
							snap, err := oCit.Next()
							if err != nil {
								panic(err)
							}
							if snap != nil {
								for _, change := range snap.Changes {
									switch change.Kind {
									case firestore.DocumentAdded:
										oCdata := change.Doc.Data()
										var candidate string = oCdata["candidate"].(string)
										var sdpMid string = oCdata["sdpMid"].(string)
										var sdpMLineIndex uint16 = uint16(oCdata["sdpMLineIndex"].(int64))

										fmt.Println("\n Here is the candidate after import from fb")
										fmt.Println(candidate)
										fmt.Println("\n Here is the sdpMid after import from fb")
										fmt.Println(sdpMid)
										fmt.Println("\n Here is the sdpMLineIndex after import from fb")
										fmt.Println(sdpMLineIndex)

										// If candidate && sdpMid && sdpMLineIndex exist then add ICE
										if candidate != "" {
											fmt.Println("adding ICE")
											ICEcandidate := webrtc.ICECandidateInit{
												Candidate:     candidate, // Assuming the "candidate" field is a string
												SDPMid:        &sdpMid,
												SDPMLineIndex: &sdpMLineIndex,
											}

											err := peerConnection.AddICECandidate(ICEcandidate)
											if err != nil {
												panic(err)
											}
											fmt.Println("post ICE added")
											break
										}
										candidate = ""
									}
								}
								break
							}
						}

					}
				}
			}
		}
		// go jpgFileWrangler() // Keep jpg file count in check to prevent overload
	}
}

// Below contains same code but save off images in frames folder. Seems to fail at a high
// rate for some reason

// package main

// import (
// 	"context"
// 	"fmt"
// 	"log"
// 	"os"
// 	"path/filepath"
// 	"strconv"
// 	"strings"
// 	"time"

// 	"bytes"
// 	"image/jpeg"

// 	"github.com/pion/rtp"
// 	"github.com/pion/rtp/codecs"
// 	"github.com/pion/webrtc/v4/pkg/media/samplebuilder"
// 	"golang.org/x/image/vp8"

// 	"github.com/pion/interceptor"
// 	"github.com/pion/interceptor/pkg/intervalpli"
// 	"github.com/pion/webrtc/v4"
// 	"github.com/pion/webrtc/v4/pkg/media"
// 	"github.com/pion/webrtc/v4/pkg/media/ivfwriter"
// 	"github.com/pion/webrtc/v4/pkg/media/oggwriter"

// 	"cloud.google.com/go/firestore"
// 	firebase "firebase.google.com/go"
// 	"google.golang.org/api/option"
// )

// var rtpChan chan *rtp.Packet

// func saveToDisk(i media.Writer, track *webrtc.TrackRemote, path string) {
// 	defer func() {
// 		if err := i.Close(); err != nil {
// 			panic(err)
// 		}
// 	}()

// 	// // Check if img save path exists and if not - create it
// 	// var path string = filepath.Join(".", "frames")
// 	// if _, err := os.Stat(path); err != nil {
// 	// 	if os.IsNotExist(err) {
// 	// 		// file does not exist
// 	// 		err := os.MkdirAll(path, os.ModePerm)
// 	// 		if err != nil {
// 	// 			panic(err)
// 	// 		}

// 	// 	}
// 	// }

// 	go snapshot(path)

// 	for {
// 		rtpPacket, _, err := track.ReadRTP()
// 		if err != nil {
// 			fmt.Println(err)
// 			return
// 		}
// 		if err := i.WriteRTP(rtpPacket); err != nil {
// 			fmt.Println(err)
// 			return
// 		}
// 		// Use a lossy channel to send packets to snapshot handler
// 		// We don't want to block and queue up old data
// 		select {
// 		case rtpChan <- rtpPacket:
// 		default:
// 		}
// 	}
// }

// func snapshot(path string) {
// 	// Initialized with 20 maxLate, my samples sometimes 10-15 packets
// 	sampleBuilder := samplebuilder.New(20, &codecs.VP8Packet{}, 90000)
// 	decoder := vp8.NewDecoder()

// 	for {
// 		// Pull RTP Packet from rtpChan
// 		sampleBuilder.Push(<-rtpChan)

// 		// Use SampleBuilder to generate full picture from many RTP Packets
// 		sample := sampleBuilder.Pop()
// 		if sample == nil {
// 			continue
// 		}

// 		// Read VP8 header.
// 		videoKeyframe := (sample.Data[0]&0x1 == 0)
// 		if !videoKeyframe {
// 			continue
// 		}

// 		// Begin VP8-to-image decode: Init->DecodeFrameHeader->DecodeFrame
// 		decoder.Init(bytes.NewReader(sample.Data), len(sample.Data))

// 		// Decode header
// 		if _, err := decoder.DecodeFrameHeader(); err != nil {
// 			panic(err)
// 		}

// 		// Decode Frame
// 		img, err := decoder.DecodeFrame()
// 		if err != nil {
// 			panic(err)
// 		}

// 		// Create image
// 		t := time.Now()
// 		filepath := filepath.Join(path, fmt.Sprintf("img_%s.jpg", t.Format("2000_01_01_15_04_05")))
// 		f, err := os.Create(filepath)
// 		if err != nil {
// 			panic(err)
// 		}
// 		if err = jpeg.Encode(f, img, nil); err != nil {
// 			panic(err)
// 		}
// 	}
// }

// func exists(path string) (bool, error) {
// 	_, err := os.Stat(path)
// 	if err == nil {
// 		return true, nil
// 	}
// 	if os.IsNotExist(err) {
// 		return false, nil
// 	}
// 	return false, err
// }

// func main() {

// 	rtpChan = make(chan *rtp.Packet)

// 	// Check if img save path exists and if not - create it
// 	var path string = filepath.Join(".", "frames")
// 	if _, err := os.Stat(path); err != nil {
// 		if os.IsNotExist(err) {
// 			// file does not exist
// 			err := os.MkdirAll(path, os.ModePerm)
// 			if err != nil {
// 				panic(err)
// 			}

// 		}
// 	}

// 	//// Firebase init /////

// 	const uid = "RJ0pPZEpmqPdiwMNBsuErIKU8zI3" // hardcode my uid
// 	const path_to_serviceAccountKey = "brightpaw-d6fd6-firebase-adminsdk-qqfyk-248ef821b0.json"
// 	const projectID = "brightpaw-d6fd6"

// 	// Initialize Cloud Firestore
// 	opt := option.WithCredentialsFile(path_to_serviceAccountKey)
// 	app, err := firebase.NewApp(context.Background(), nil, opt)
// 	if err != nil {
// 		fmt.Println("error initializing app: %w", err)
// 	}

// 	// Initialize the Firebase Admin SDK
// 	ctx := context.Background()

// 	////////////////////////

// 	// Create a MediaEngine object to configure the supported codec
// 	m := &webrtc.MediaEngine{}

// 	// Setup the codecs you want to use.
// 	// We'll use a VP8 and Opus but you can also define your own
// 	if err := m.RegisterCodec(webrtc.RTPCodecParameters{
// 		RTPCodecCapability: webrtc.RTPCodecCapability{MimeType: webrtc.MimeTypeVP8, ClockRate: 90000, Channels: 0, SDPFmtpLine: "", RTCPFeedback: nil},
// 		PayloadType:        96,
// 	}, webrtc.RTPCodecTypeVideo); err != nil {
// 		panic(err)
// 	}
// 	if err := m.RegisterCodec(webrtc.RTPCodecParameters{
// 		RTPCodecCapability: webrtc.RTPCodecCapability{MimeType: webrtc.MimeTypeOpus, ClockRate: 48000, Channels: 0, SDPFmtpLine: "", RTCPFeedback: nil},
// 		PayloadType:        111,
// 	}, webrtc.RTPCodecTypeAudio); err != nil {
// 		panic(err)
// 	}

// 	//// Possibly remove this chunk ////

// 	// Create a InterceptorRegistry. This is the user configurable RTP/RTCP Pipeline.
// 	// This provides NACKs, RTCP Reports and other features. If you use `webrtc.NewPeerConnection`
// 	// this is enabled by default. If you are manually managing You MUST create a InterceptorRegistry
// 	// for each PeerConnection.
// 	i := &interceptor.Registry{}

// 	// Register a intervalpli factory
// 	// This interceptor sends a PLI every 3 seconds. A PLI causes a video keyframe to be generated by the sender.
// 	// This makes our video seekable and more error resilent, but at a cost of lower picture quality and higher bitrates
// 	// A real world application should process incoming RTCP packets from viewers and forward them to senders
// 	intervalPliFactory, err := intervalpli.NewReceiverInterceptor()
// 	if err != nil {
// 		panic(err)
// 	}
// 	i.Add(intervalPliFactory)

// 	// Use the default set of Interceptors
// 	if err = webrtc.RegisterDefaultInterceptors(m, i); err != nil {
// 		panic(err)
// 	}

// 	/////////////////////////////

// 	// Create the API object with the MediaEngine
// 	api := webrtc.NewAPI(webrtc.WithMediaEngine(m), webrtc.WithInterceptorRegistry(i))

// 	// Prepare the configuration
// 	config := webrtc.Configuration{
// 		ICEServers: []webrtc.ICEServer{
// 			{
// 				URLs: []string{"stun:stun.l.google.com:19302"},
// 			},
// 		},
// 	}

// 	// Create a new RTCPeerConnection
// 	peerConnection, err := api.NewPeerConnection(config)
// 	if err != nil {
// 		panic(err)
// 	}

// 	// Allow us to receive 1 audio track, and 1 video track
// 	if _, err = peerConnection.AddTransceiverFromKind(webrtc.RTPCodecTypeAudio); err != nil {
// 		panic(err)
// 	} else if _, err = peerConnection.AddTransceiverFromKind(webrtc.RTPCodecTypeVideo); err != nil {
// 		panic(err)
// 	}

// 	oggFile, err := oggwriter.New("output.ogg", 48000, 2)
// 	if err != nil {
// 		panic(err)
// 	}
// 	ivfFile, err := ivfwriter.New("output.ivf")
// 	if err != nil {
// 		panic(err)
// 	}

// 	// Set a handler for when a new remote track starts, this handler saves buffers to disk as
// 	// an ivf file, since we could have multiple video tracks we provide a counter.
// 	// In your application this is where you would handle/process video
// 	peerConnection.OnTrack(func(track *webrtc.TrackRemote, receiver *webrtc.RTPReceiver) {
// 		codec := track.Codec()
// 		if strings.EqualFold(codec.MimeType, webrtc.MimeTypeOpus) {
// 			fmt.Println("Got Opus track, saving to disk as output.opus (48 kHz, 2 channels)")
// 			saveToDisk(oggFile, track, path)
// 		} else if strings.EqualFold(codec.MimeType, webrtc.MimeTypeVP8) {
// 			fmt.Println("Got VP8 track, saving to disk as output.ivf")
// 			saveToDisk(ivfFile, track, path)
// 		}
// 	})

// 	// Set the handler for ICE connection state
// 	// This will notify you when the peer has connected/disconnected
// 	peerConnection.OnICEConnectionStateChange(func(connectionState webrtc.ICEConnectionState) {
// 		fmt.Printf("Connection State has changed %s \n", connectionState.String())

// 		if connectionState == webrtc.ICEConnectionStateConnected {
// 			fmt.Println("Ctrl+C the remote client to stop the demo")
// 		} else if connectionState == webrtc.ICEConnectionStateFailed || connectionState == webrtc.ICEConnectionStateClosed {
// 			if closeErr := oggFile.Close(); closeErr != nil {
// 				panic(closeErr)
// 			}

// 			if closeErr := ivfFile.Close(); closeErr != nil {
// 				panic(closeErr)
// 			}

// 			fmt.Println("Done writing media files")

// 			// Gracefully shutdown the peer connection
// 			if closeErr := peerConnection.Close(); closeErr != nil {
// 				panic(closeErr)
// 			}

// 			os.Exit(0)
// 		}
// 	})

// 	///////////////////

// 	// Setup Context
// 	ctx, cancel := context.WithCancel(ctx)
// 	defer cancel()

// 	client, err := app.Firestore(ctx)
// 	if err != nil {
// 		log.Fatalln(err)
// 	}

// 	if err != nil {
// 		fmt.Println("firestore.NewClient: %w", err)
// 	}
// 	defer client.Close()

// 	// firebase ref's
// 	var callRef = client.Collection("users").Doc(uid).Collection("calls").NewDoc()
// 	offerCandidates := callRef.Collection("offerCandidates").NewDoc()
// 	uidDoc := client.Collection("users").Doc(uid)

// 	// // set latest caller + upload to firebase
// 	// _, Uerr := uidDoc.Update(ctx, []firestore.Update{
// 	// 	{
// 	// 		Path:  "latestCall",
// 	// 		Value: callRef.ID,
// 	// 	},
// 	// })
// 	// if Uerr != nil {
// 	// 	// Handle any errors in an appropriate way, such as returning them.
// 	// 	log.Printf("An error has occurred when updating latest call: %s", Uerr)
// 	// }

// 	// Register the onICECandidate event handler (offer candidate + upload to fb)
// 	peerConnection.OnICECandidate(func(event *webrtc.ICECandidate) {
// 		// onICECandidateJS(peerConnection, event, ctx)
// 		if event != nil {
// 			candidateJSON := event.ToJSON()

// 			// Convert to readable format on Firebase for User on WebRTC js side to process
// 			offercandidateFB := OfferCandidateFB{
// 				Candidate:     candidateJSON.Candidate,
// 				SDPMLineIndex: int64(*candidateJSON.SDPMLineIndex),
// 				SDPMid:        strconv.Itoa(int(*candidateJSON.SDPMLineIndex)), // value is blank, so use SDPMLineIndex for now
// 			}

// 			_, err := offerCandidates.Set(ctx, offercandidateFB)
// 			if err != nil {
// 				// Handle any errors in an appropriate way, such as returning them.
// 				log.Printf("An error has occurred on setting offerCandidates: %s", err)
// 			}

// 		}
// 	})

// 	// Create offer
// 	offerDescription, err := peerConnection.CreateOffer(nil)
// 	if err != nil {
// 		panic(err)
// 	}

// 	// set local desc
// 	peerConnection.SetLocalDescription(offerDescription)

// 	// upload to firebase
// 	soff := StartOffer{
// 		example: "placeholder",
// 	}
// 	SecOffer := Offer{
// 		Type: "offer",
// 		SDP:  offerDescription.SDP,
// 	}
// 	// Offer := OuterOffer{
// 	// 	Offer: Offer{
// 	// 		Type: "offer",
// 	// 		SDP:  offerDescription.SDP,
// 	// 	},
// 	// }
// 	// fmt.Println(Offer)
// 	// _, UOerr := callRef.Update(ctx, []firestore.Update{
// 	// 	{
// 	// 		Path:  "offer",
// 	// 		Value: offer,
// 	// 	},
// 	// })
// 	_, UOerr := callRef.Set(ctx, soff) // then updat ?
// 	if UOerr != nil {
// 		// Handle any errors in an appropriate way, such as returning them.
// 		log.Printf("An error has occurred on offer upload update: %s", UOerr)
// 	}
// 	_, UOerr2 := callRef.Update(ctx, []firestore.Update{
// 		{
// 			Path:  "offer",
// 			Value: SecOffer,
// 		},
// 	})
// 	if UOerr2 != nil {
// 		// Handle any errors in an appropriate way, such as returning them.
// 		log.Printf("An error has occurred on offer upload update: %s", UOerr2)
// 	}

// 	// set latest caller + upload to firebase
// 	_, Uerr := uidDoc.Update(ctx, []firestore.Update{
// 		{
// 			Path:  "latestCall",
// 			Value: callRef.ID,
// 		},
// 	})
// 	if Uerr != nil {
// 		// Handle any errors in an appropriate way, such as returning them.
// 		log.Printf("An error has occurred when updating latest call: %s", Uerr)
// 	}

// 	// onSnapshot - listen for remote answer
// 	// set remote desc
// 	dit := callRef.Snapshots(ctx)
// 	for {
// 		snap, err := dit.Next()
// 		// DeadlineExceeded will be returned when ctx is cancelled.
// 		// if status.Code(err) == codes.DeadlineExceeded {
// 		// 	return
// 		// }
// 		if err != nil {
// 			return
// 		}
// 		// if !snap.Exists() {
// 		// 	fmt.Println("Document no longer exists")
// 		// 	return
// 		// }
// 		if snap != nil {
// 			data := snap.Data()

// 			// check if data map has key answer
// 			_, hasAnswer := data["answer"]
// 			CurrRemoteDesc := peerConnection.CurrentRemoteDescription()
// 			fmt.Println("Current Remote Desc")
// 			fmt.Println(CurrRemoteDesc)

// 			if hasAnswer && CurrRemoteDesc == nil {
// 				answerDescription := data["answer"]
// 				// Break down interface into sdp
// 				if value, ok := answerDescription.(map[string]interface{}); ok {
// 					fieldValue := value["sdp"]
// 					if sdpStrValue, ok := fieldValue.(string); ok {

// 						// Set the remote SessionDescription
// 						answer := webrtc.SessionDescription{
// 							Type: webrtc.SDPTypeAnswer,
// 							SDP:  sdpStrValue,
// 						}

// 						// Create channel that is blocked until ICE Gathering is complete
// 						fmt.Println("Starting setRemoteDescription")
// 						fmt.Println(answer)
// 						fmt.Println("Ended Answer")
// 						// gatherCompleteRem := webrtc.GatheringCompletePromise(peerConnection)
// 						var err error
// 						if err = peerConnection.SetRemoteDescription(answer); err != nil {
// 							panic(err)
// 						}

// 						///////////

// 						// onSnapshot - get answer candidates
// 						// Add answerCandidates to RTCIceCandidate
// 						fmt.Println("\nChecking docs in answerCandidates....")
// 						oCit := callRef.Collection("answerCandidates").Snapshots(ctx)
// 						for {
// 							snap, err := oCit.Next()
// 							if err != nil {
// 								panic(err)
// 							}
// 							if snap != nil {
// 								for _, change := range snap.Changes {
// 									switch change.Kind {
// 									case firestore.DocumentAdded:
// 										oCdata := change.Doc.Data()
// 										var candidate string = oCdata["candidate"].(string)
// 										var sdpMid string = oCdata["sdpMid"].(string)
// 										var sdpMLineIndex uint16 = uint16(oCdata["sdpMLineIndex"].(int64))

// 										fmt.Println("\n Here is the candidate after import from fb")
// 										fmt.Println(candidate)
// 										fmt.Println("\n Here is the sdpMid after import from fb")
// 										fmt.Println(sdpMid)
// 										fmt.Println("\n Here is the sdpMLineIndex after import from fb")
// 										fmt.Println(sdpMLineIndex)

// 										// If candidate && sdpMid && sdpMLineIndex exist then add ICE
// 										if candidate != "" {
// 											fmt.Println("adding ICE")
// 											ICEcandidate := webrtc.ICECandidateInit{
// 												Candidate:     candidate, // Assuming the "candidate" field is a string
// 												SDPMid:        &sdpMid,
// 												SDPMLineIndex: &sdpMLineIndex,
// 											}

// 											err := peerConnection.AddICECandidate(ICEcandidate)
// 											if err != nil {
// 												panic(err)
// 											}
// 											fmt.Println("post ICE added")
// 											break
// 										}
// 										candidate = ""
// 									}
// 								}
// 								break
// 							}
// 						}

// 					}
// 				}
// 			}
// 		}
// 	}
// }
